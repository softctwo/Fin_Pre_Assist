# 测试体系建立指南

## 概述

本文档为金融售前方案辅助系统建立了完整的测试体系，涵盖前端、后端、CI/CD集成和最佳实践。

## 测试架构概览

### 技术栈
- **前端测试**: Vitest + React Testing Library + jsdom
- **后端测试**: pytest + pytest-asyncio + FastAPI TestClient
- **覆盖率**: V8 (前端) + pytest-cov (后端)
- **CI/CD**: GitHub Actions

### 目录结构
```
backend/
├── tests/                    # 后端测试
├── pytest.ini               # pytest配置
├── requirements-dev.txt     # 测试依赖
└── run_tests.sh            # 测试脚本

frontend/
├── src/
│   ├── components/__tests__/  # 组件测试
│   └── pages/__tests__/      # 页面测试
├── vitest.config.ts         # Vitest配置
└── vitest.setup.ts         # 测试环境设置
```

## 前端测试策略

### 1. 测试框架配置

**vitest.config.ts**
```typescript
export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: ['./vitest.setup.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'html', 'lcov'],
      reportsDirectory: './coverage'
    }
  }
})
```

### 2. 测试类型

#### 组件测试 (Component Testing)
```typescript
// 示例：HealthBadge.test.tsx
import { render, screen } from '@testing-library/react'

describe('HealthBadge', () => {
  it('renders health status correctly', () => {
    render(<HealthBadge status="healthy" />)
    expect(screen.getByText('系统正常')).toBeInTheDocument()
  })
})
```

#### 页面测试 (Page Testing)
```typescript
// 示例：Dashboard.test.tsx
import { vi, describe, it, expect } from 'vitest'

vi.mock('../../services/metricsService', () => ({
  getMetricsSummary: vi.fn(),
}))

describe('Dashboard', () => {
  it('displays metrics data when API succeeds', async () => {
    mockedGetMetricsSummary.mockResolvedValue({
      documents: 10,
      proposals: 5,
      cache_hit_rate: '80.00%'
    })

    render(<Dashboard />)

    await waitFor(() => {
      expect(screen.getByText('文档总数')).toBeInTheDocument()
    })
  })
})
```

### 3. 测试最佳实践

#### Mock策略
```typescript
// 服务mock
vi.mock('../../services/api', () => ({
  fetchDocuments: vi.fn(),
  createProposal: vi.fn()
}))

// 模块mock
vi.mock('react-router-dom', () => ({
  useNavigate: vi.fn()
}))
```

#### 异步测试
```typescript
it('handles async operations', async () => {
  render(<AsyncComponent />)

  await waitFor(() => {
    expect(screen.getByText('加载完成')).toBeInTheDocument()
  })
})
```

## 后端测试策略

### 1. 测试配置

**pytest.ini**
```ini
[pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = -v --tb=short
```

**conftest.py - 核心fixtures**
```python
@pytest.fixture(scope="function")
def test_client(test_db):
    """创建测试客户端"""
    return TestClient(app)

@pytest.fixture
def test_user(test_db: Session):
    """创建测试用户"""
    user = User(
        username="testuser",
        email="test@example.com",
        password_hash=get_password_hash("Test123Pass"),
        role=UserRole.USER
    )
    test_db.add(user)
    test_db.commit()
    return user

@pytest.fixture
def auth_headers(auth_token: str):
    """获取认证头"""
    return {"Authorization": f"Bearer {auth_token}"}
```

### 2. 测试类型

#### 单元测试 (Unit Testing)
```python
# 示例：test_ai_service_unit.py
def test_openai_provider_success():
    """测试OpenAI服务成功响应"""
    with patch('httpx.AsyncClient') as mock_client:
        mock_response = MagicMock()
        mock_response.json.return_value = {
            "choices": [{"message": {"content": "生成的内容"}}]
        }
        mock_client.return_value.post.return_value = mock_response

        service = AIService()
        result = service.generate_content("测试提示")

        assert "生成的内容" in result
```

#### 集成测试 (Integration Testing)
```python
# 示例：test_api_integration.py
async def test_create_document_flow(test_client, auth_headers):
    """测试文档创建完整流程"""
    # 上传文档
    with open("test.pdf", "rb") as f:
        response = test_client.post(
            "/api/v1/documents/upload",
            files={"file": ("test.pdf", f, "application/pdf")},
            headers=auth_headers
        )

    assert response.status_code == 201
    doc_id = response.json()["id"]

    # 验证文档处理
    response = test_client.get(f"/api/v1/documents/{doc_id}", headers=auth_headers)
    assert response.status_code == 200
    assert response.json()["status"] == "processed"
```

#### 安全测试 (Security Testing)
```python
# 示例：test_xss_security.py
def test_xss_prevention_in_proposal_content():
    """测试XSS攻击防护"""
    malicious_content = "<script>alert('XSS')</script>"

    response = test_client.post(
        "/api/v1/proposals",
        json={"content": malicious_content},
        headers=auth_headers
    )

    assert response.status_code == 201
    # 验证内容被正确转义
    assert "&lt;script&gt;" in response.json()["content"]
```

### 3. 数据库测试策略

#### 测试数据库配置
```python
# 使用SQLite内存数据库
SQLALCHEMY_DATABASE_URL = "sqlite:///./test.db"
engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})
```

#### 事务管理
```python
@pytest.fixture(scope="function")
def test_db():
    """每个测试函数独立数据库"""
    Base.metadata.create_all(bind=engine)
    db = TestingSessionLocal()
    try:
        yield db
    finally:
        db.close()
        Base.metadata.drop_all(bind=engine)
```

## CI/CD集成测试

### 1. GitHub Actions配置

**测试矩阵策略**
```yaml
strategy:
  matrix:
    python-version: [3.9, 3.10]

services:
  postgres:
    image: postgres:14
    env:
      POSTGRES_PASSWORD: testpass
    options: >-
      --health-cmd pg_isready
      --health-interval 10s
      --health-timeout 5s
      --health-retries 5
```

**测试步骤**
```yaml
steps:
  - name: Run backend tests
    run: |
      cd backend
      pytest tests/ --cov=app --cov-report=html --cov-fail-under=55

  - name: Run frontend tests
    run: |
      cd frontend
      npm run test:coverage
```

### 2. 覆盖率要求

- **后端覆盖率**: 55% (最低要求)
- **前端覆盖率**: 自动生成报告
- **总体目标**: 70%+

### 3. 质量门禁

```yaml
- name: Code quality checks
  run: |
    flake8 backend/ --max-line-length=88
    black backend/ --check
    mypy backend/ --ignore-missing-imports

- name: Security scan
  run: |
    bandit -r backend/
    safety check
```

## 测试运行指南

### 本地开发测试

#### 快速测试
```bash
# 后端测试
cd backend && pytest tests/ -v

# 前端测试
cd frontend && npm test

# 指定测试文件
cd backend && pytest tests/test_ai_service_unit.py -v
cd frontend && npm test -- Dashboard.test.tsx
```

#### 覆盖率测试
```bash
# 后端覆盖率
cd backend && pytest tests/ --cov=app --cov-report=html --cov-fail-under=70

# 前端覆盖率
cd frontend && npm run test:coverage
```

#### 并行测试
```bash
# 后端并行测试
cd backend && pytest tests/ -n auto

# 前端并行测试（Vitest默认并行）
cd frontend && npm test
```

### 完整测试套件

```bash
# 一键运行所有测试
bash backend/run_tests.sh

# 包含质量检查
bash backend/run_tests.sh --with-quality
```

## 测试数据管理

### 1. Fixtures管理

```python
# conftest.py中的共享fixtures
@pytest.fixture
def sample_document():
    """创建示例文档"""
    return {
        "title": "测试文档",
        "content": "这是一个测试文档内容",
        "type": "pdf"
    }
```

### 2. Mock数据策略

```python
# 使用factory_boy创建测试数据
class UserFactory(factory.Factory):
    class Meta:
        model = User

    username = factory.Sequence(lambda n: f"user{n}")
    email = factory.LazyAttribute(lambda obj: f"{obj.username}@example.com")
```

### 3. 测试环境隔离

```python
# 独立的测试环境变量
os.environ["TESTING"] = "true"
os.environ["DATABASE_URL"] = "sqlite:///./test.db"
os.environ["CHROMA_PERSIST_DIRECTORY"] = "./test_chroma"
```

## 性能测试

### 1. 负载测试配置

```python
# 使用Locust进行性能测试
from locust import HttpUser, task, between

class WebsiteUser(HttpUser):
    wait_time = between(1, 3)

    @task
def view_proposals(self):
        self.client.get("/api/v1/proposals")
```

### 2. 性能基准

```yaml
性能目标:
  API响应时间: < 200ms (P95)
  并发用户数: 100+
  数据库查询: < 50ms
  内存使用: < 500MB
```

## 故障排查指南

### 常见测试问题

1. **异步测试超时**
   ```python
   @pytest.mark.asyncio
   async def test_with_timeout():
       # 设置超时时间
       result = await asyncio.wait_for(async_operation(), timeout=5.0)
   ```

2. **数据库锁定**
   ```python
   # 使用独立数据库实例
   SQLALCHEMY_DATABASE_URL = "sqlite:///./test_{uuid}.db"
   ```

3. **Mock对象泄漏**
   ```python
   @pytest.fixture(autouse=True)
   def cleanup():
       yield
       # 清理所有mock
       mock.resetall()
   ```

### 调试技巧

```python
# 使用pdb调试
import pdb; pdb.set_trace()

# 详细日志
pytest tests/ -v -s --log-cli-level=DEBUG

# 仅运行失败的测试
pytest tests/ --lf
```

## 测试文档和维护

### 1. 测试文档模板

```markdown
## 模块测试文档

### 测试范围
- 功能点1
- 功能点2

### 测试用例
1. 正常流程测试
2. 异常流程测试
3. 边界条件测试

### 覆盖率目标
- 语句覆盖率: 80%
- 分支覆盖率: 70%
- 函数覆盖率: 90%
```

### 2. 测试维护清单

- [ ] 定期更新测试数据
- [ ] 检查废弃的测试用例
- [ ] 更新mock数据
- [ ] 性能基准测试
- [ ] 安全测试更新

## 持续改进

### 1. 测试度量指标

```yaml
关键指标:
  测试覆盖率: 目标70%+
  测试执行时间: 目标<5分钟
  测试稳定性: 目标>95%
  缺陷检测率: 目标>80%
```

### 2. 优化策略

1. **测试分层**: 单元测试 -> 集成测试 -> 端到端测试
2. **并行执行**: 利用多核CPU并行运行测试
3. **智能测试**: 基于代码变更选择相关测试
4. **测试即文档**: 测试代码作为活文档维护

## 总结

本测试体系建立了从前端到后端、从单元到集成、从功能到安全的完整测试覆盖，通过CI/CD自动化确保代码质量，为金融售前方案辅助系统提供了可靠的质量保障。